import random
import math
import copy
import os
import json
import sys
import subprocess
from typing import List, Dict, Any, Optional
from datetime import datetime
from urllib.parse import quote
import shutil

from storyteller.algorithm.mcts_node import MCTSNode, Report, ReportGenerationState
from storyteller.algorithm.mcts_action import (
    DataStorytellingAction,
    Query2Chapters,
    Chapters2Tasks,
    Tasks2Charts,
    ReviseVis,
    Charts2Captions,
    Captions2Summaries,
)
NODE_TYPE_TO_VALID_ACTIONS = {
    ReportGenerationState.EMPTY: [
        Query2Chapters
    ],
    ReportGenerationState.a1: [
        Chapters2Tasks
    ],
    ReportGenerationState.a2: [
        Tasks2Charts
    ],
    ReportGenerationState.a3: [
        ReviseVis,
        Charts2Captions
    ],
    ReportGenerationState.a4: [
        Charts2Captions
    ],
    ReportGenerationState.a5: [
        Captions2Summaries
    ],
    ReportGenerationState.FINALIZED: []  # ç»ˆæ­¢çŠ¶æ€
}
from storyteller.algorithm.reward import StorytellingRewardModel
from .utils.html2image import convert_html_file_to_image

class DataStorytellingMCTSSolver:
    def __init__(self, 
                 original_query: str,
                 dataset_path: str,
                 output_dir: str,
                 max_iterations: int = 100,
                 max_depth: int = 10,
                 exploration_constant: float = 1.414,
                 data_context: str = "",
                 llm_kwargs: dict = None):
        """
        MCTS è§£å†³å™¨ï¼Œç”¨äºæ•°æ®æ•…äº‹è‡ªåŠ¨ç”Ÿæˆã€‚

        å‚æ•°:
            original_query: ç”¨æˆ·è¾“å…¥çš„é—®é¢˜
            dataset_path: æ•°æ®é›†è·¯å¾„
            output_dir: è¾“å‡ºç›®å½•
            max_iterations: æœ€å¤§æœç´¢è¿­ä»£æ¬¡æ•°
            max_depth: æœ€å¤§æœç´¢æ·±åº¦
            exploration_constant: UCB1 å…¬å¼ä¸­çš„æ¢ç´¢å¸¸æ•°
            data_context: æ•°æ®é›†çš„ä¸Šä¸‹æ–‡ä¿¡æ¯
            llm_kwargs: ä¼ é€’ç»™ LLMï¼ˆå¤§æ¨¡å‹ï¼‰çš„å‚æ•°
        """
        self.original_query = original_query
        self.dataset_path = dataset_path
        self.output_dir = output_dir
        self.max_iterations = max_iterations
        self.max_depth = max_depth
        self.exploration_constant = exploration_constant
        self.data_context = json.load(open(data_context, 'r', encoding='utf-8'))
        self.llm_kwargs = llm_kwargs or {}

        # åˆ›å»ºå¥–åŠ±æ¨¡å‹
        self.reward_model = StorytellingRewardModel(llm_kwargs=self.llm_kwargs)

        # å®šä¹‰åŠ¨ä½œç©ºé—´
        self.action_space = [
            Query2Chapters(),
            Chapters2Tasks(),
            Tasks2Charts(),
            ReviseVis(),
            Charts2Captions(),
            Captions2Summaries()
        ]

        # ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
        os.makedirs(self.output_dir, exist_ok=True)

        # åˆå§‹åŒ–æ ¹èŠ‚ç‚¹ - ä½¿ç”¨åŸæœ‰çš„ MCTSNode åˆå§‹åŒ–æ–¹å¼
        self.root = MCTSNode(
            node_type=ReportGenerationState.EMPTY,
            report=Report(
                original_query=self.original_query, 
                dataset_path=self.dataset_path, 
                data_context=self.data_context
            ),
            original_query=self.original_query,
            llm_kwargs=self.llm_kwargs
        )

        # æ·»åŠ æœ€ä½³èŠ‚ç‚¹è¿½è¸ª
        self.best_node = self.root
        self.best_score = float('-inf')


    def select(self, node: MCTSNode) -> MCTSNode:
        """
        é€‰æ‹©é˜¶æ®µï¼šä½¿ç”¨ UCB1 å…¬å¼é€‰æ‹©æœ€æœ‰å¸Œæœ›çš„ `Node` è¿›è¡Œæ‰©å±•ã€‚

        å‚æ•°:
            node: å½“å‰ MCTS èŠ‚ç‚¹

        è¿”å›:
            é€‰ä¸­çš„ `Node`
        """
        while node.children:
            if any(child.N == 0 for child in node.children):
                return next(child for child in node.children if child.N == 0)

            # é€‰æ‹© UCB1 è¯„åˆ†æœ€é«˜çš„å­èŠ‚ç‚¹
            node = max(node.children, key=lambda c: (c.Q / c.N) + self.exploration_constant * math.sqrt(math.log(node.N) / c.N))
        return node
    def expand(self, node: MCTSNode) -> None:
        """å±•å¼€å¶å­èŠ‚ç‚¹ï¼Œæ·»åŠ æ‰€æœ‰å¯èƒ½çš„å­èŠ‚ç‚¹"""
        print("ğŸ”„ æ‰©å±•èŠ‚ç‚¹...")
        print(f"\nè°ƒè¯•ä¿¡æ¯:")
        
        # å¦‚æœèŠ‚ç‚¹å·²ç»æœ‰å­èŠ‚ç‚¹ï¼Œå…ˆæ¸…ç©ºå®ƒä»¬
        if node.children:
            print(f"âš ï¸ èŠ‚ç‚¹ {node.node_type} åœ¨æ‰©å±•å‰å·²æœ‰ {len(node.children)} ä¸ªå­èŠ‚ç‚¹ï¼Œå°†æ¸…ç©ºè¿™äº›å­èŠ‚ç‚¹")
            node.children = []
        
        # è·å–å½“å‰èŠ‚ç‚¹çŠ¶æ€
        current_state = node.node_type
        print(f"å½“å‰çŠ¶æ€: {current_state}")
        
        # è·å–å½“å‰çŠ¶æ€å¯ç”¨çš„åŠ¨ä½œç±»å‹
        valid_action_types = NODE_TYPE_TO_VALID_ACTIONS.get(current_state, [])
        
        if not valid_action_types:
            print(f"âš ï¸ çŠ¶æ€ {current_state.name} æ²¡æœ‰æœ‰æ•ˆçš„åŠ¨ä½œç±»å‹")
            return
        
        print(f"æ‰¾åˆ° {len(valid_action_types)} ä¸ªå¯ç”¨åŠ¨ä½œç±»å‹")
        
        # éå†æ¯ä¸ªåŠ¨ä½œç±»å‹
        for action_class in valid_action_types:
            try:
                # å®ä¾‹åŒ–åŠ¨ä½œç±»
                action_instance = action_class()
                print(f"å°è¯•æ‰§è¡ŒåŠ¨ä½œ: {action_class.__name__}")
                
                # åˆ›å»ºå­èŠ‚ç‚¹
                children = action_instance.create_children_nodes(node, self.llm_kwargs)
                
                if not children:
                    print(f"âš ï¸ åŠ¨ä½œ {action_class.__name__} æ²¡æœ‰ç”Ÿæˆä»»ä½•å­èŠ‚ç‚¹ï¼Œå°è¯•åˆ›å»ºä¸€ä¸ªé»˜è®¤å­èŠ‚ç‚¹")
                    # åˆ›å»ºä¸€ä¸ªé»˜è®¤å­èŠ‚ç‚¹ï¼Œç¡®ä¿æ¯ä¸ªåŠ¨ä½œéƒ½èƒ½ç”Ÿæˆè‡³å°‘ä¸€ä¸ªå­èŠ‚ç‚¹
                    default_child = copy.deepcopy(node)
                    default_child.parent_node = node
                    default_child.parent_action = action_instance
                    default_child.depth = node.depth + 1
                    
                    # æ ¹æ®åŠ¨ä½œç±»å‹è®¾ç½®æ­£ç¡®çš„çŠ¶æ€
                    if action_class == Query2Chapters:
                        default_child.node_type = ReportGenerationState.a1
                    elif action_class == Chapters2Tasks:
                        default_child.node_type = ReportGenerationState.a2
                    elif action_class == Tasks2Charts:
                        default_child.node_type = ReportGenerationState.a3
                    elif action_class == ReviseVis:
                        default_child.node_type = ReportGenerationState.a4
                    elif action_class == Charts2Captions:
                        default_child.node_type = ReportGenerationState.a5
                    elif action_class == Captions2Summaries:
                        default_child.node_type = ReportGenerationState.FINALIZED
                    
                    children = [default_child]
                    print(f"âœ… ä¸ºåŠ¨ä½œ {action_class.__name__} åˆ›å»ºäº†ä¸€ä¸ªé»˜è®¤å­èŠ‚ç‚¹")
                else:
                    print(f"âœ… åŠ¨ä½œ {action_class.__name__} ç”Ÿæˆäº† {len(children)} ä¸ªå­èŠ‚ç‚¹")
                
                # æ·»åŠ å­èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹
                node.children.extend(children)
                
                # ç¡®ä¿æ‰€æœ‰æ–°åˆ›å»ºçš„å­èŠ‚ç‚¹ç»§æ‰¿å½“å‰çš„è¿­ä»£å·
                current_iteration = self.root.report.current_iteration
                for child in children:
                    child.report.current_iteration = current_iteration
                
            except Exception as e:
                print(f"âŒ æ‰§è¡ŒåŠ¨ä½œ {action_class.__name__} æ—¶å‡ºé”™: {str(e)}")
                import traceback
                traceback.print_exc()
        
        # æ£€æŸ¥æ˜¯å¦ç”Ÿæˆäº†å­èŠ‚ç‚¹
        if not node.children:
            print("âš ï¸ æ‰©å±•åæ²¡æœ‰ç”Ÿæˆä»»ä½•å­èŠ‚ç‚¹")
        else:
            print(f"âœ… å…±ç”Ÿæˆ {len(node.children)} ä¸ªå­èŠ‚ç‚¹")
        
        # éšæœºæ‰“ä¹±å­èŠ‚ç‚¹é¡ºåº
        random.shuffle(node.children)

    def simulate(self, node: MCTSNode) -> tuple[MCTSNode, float]:
        """æ¨¡æ‹Ÿé˜¶æ®µï¼šä»å½“å‰èŠ‚ç‚¹å¼€å§‹éšæœºæ‰§è¡ŒåŠ¨ä½œï¼Œç›´åˆ°è¾¾åˆ°ç»ˆæ­¢çŠ¶æ€"""
        print("ğŸ”„ æ¨¡æ‹Ÿé˜¶æ®µ...")
        
        # åˆ›å»ºå‰¯æœ¬å¹¶ä¿æŒæ­£ç¡®çš„è¿­ä»£å·
        current = copy.deepcopy(node)
        current.report.current_iteration = self.root.report.current_iteration
        
        # åˆå§‹åŒ–é»˜è®¤å¥–åŠ±å€¼
        reward = 5.0  # é»˜è®¤å¥–åŠ±å€¼
        
        # å¾ªç¯ç›´åˆ°è¾¾åˆ°ç»ˆæ­¢çŠ¶æ€
        while not current.is_terminal() and current.depth < self.max_depth:
            # è·å–å½“å‰çŠ¶æ€ä¸‹çš„åˆæ³•åŠ¨ä½œ
            self.expand(current)
            
            # æ£€æŸ¥æ˜¯å¦æœ‰å­èŠ‚ç‚¹
            if not current.children:
                print("âš ï¸ å½“å‰èŠ‚ç‚¹æ‰©å±•åæ²¡æœ‰å­èŠ‚ç‚¹ï¼Œåœæ­¢æ¨¡æ‹Ÿ")
                break
            
            # éšæœºé€‰æ‹©ä¸€ä¸ªå­èŠ‚ç‚¹
            current = random.choice(current.children)
            # ç¡®ä¿å­èŠ‚ç‚¹ä¹Ÿæœ‰æ­£ç¡®çš„è¿­ä»£å·
            current.report.current_iteration = self.root.report.current_iteration
            print(f"â¡ï¸ æ¨¡æ‹Ÿè¿›å…¥çŠ¶æ€: {current.node_type.name} (æ·±åº¦ {current.depth})")
        
        # å¦‚æœè¾¾åˆ°ç»ˆæ­¢çŠ¶æ€ï¼Œè¿›è¡Œè´¨é‡è¯„ä¼°
        if current.is_terminal():
            print("âœ… æ¨¡æ‹Ÿç”Ÿæˆäº†å®Œæ•´æŠ¥å‘Šï¼")
            
            # åˆ›å»ºå½“å‰è¿­ä»£çš„ç›®å½•
            iteration_dir = os.path.join(self.output_dir, "iterations", f"iteration_{current.report.current_iteration}")
            os.makedirs(iteration_dir, exist_ok=True)
            
            # ä½¿ç”¨_save_html_reportç”Ÿæˆæ‰€æœ‰æŠ¥å‘Š (å·²åŒ…å«Markdownå’ŒHTMLçš„ç”Ÿæˆ)
            # åŒæ—¶è¿”å›åŸå§‹HTMLå†…å®¹(ç”¨ç»å¯¹è·¯å¾„)
            html_path, original_contents = self._save_html_report(current, os.path.join(iteration_dir, "report.html"))
            
            # è·å–æ‰€æœ‰ç”Ÿæˆçš„HTMLæ–‡ä»¶
            html_dir = os.path.dirname(html_path)
            html_files = [f for f in os.listdir(html_dir) if f.endswith('.html')]
            
            png_path = None
            if html_files:
                # éšæœºé€‰æ‹©ä¸€ä¸ªHTMLæ–‡ä»¶è¿›è¡ŒPNGè½¬æ¢
                selected_html = random.choice(html_files)
                selected_html_path = os.path.join(html_dir, selected_html)
                print(f"\nğŸ² éšæœºé€‰æ‹© {selected_html} è½¬æ¢ä¸ºPNG...")
                
                # ä½¿ç”¨åŸå§‹å†…å®¹(ç»å¯¹è·¯å¾„)ä¸´æ—¶ä¿å­˜æ–‡ä»¶ç”¨äºPNGè½¬æ¢
                if selected_html in original_contents:
                    with open(selected_html_path, 'w', encoding='utf-8') as f:
                        f.write(original_contents[selected_html])
                
                # è½¬æ¢ä¸ºPNG
                png_path = os.path.splitext(selected_html_path)[0] + ".png"
                convert_html_file_to_image(selected_html_path, png_path)
                print(f"âœ… PNGæ–‡ä»¶å·²ç”Ÿæˆ: {png_path}")
                
                # æ¢å¤ä¸ºç›¸å¯¹è·¯å¾„ç‰ˆæœ¬
                html_content = original_contents[selected_html]
                user_home = os.path.expanduser("~")
                project_base = os.path.join(user_home, "mcts")
                if os.path.exists(project_base):
                    html_content = html_content.replace(project_base, "")
                else:
                    import re
                    pattern = r'(src=")(\/.*?\/mcts)(\/storyteller\/.*?\.png")'
                    html_content = re.sub(pattern, r'\1\3', html_content)
                
                with open(selected_html_path, 'w', encoding='utf-8') as f:
                    f.write(html_content)
            
            try:
                # ä»…å½“æœ‰PNGå›¾è¡¨æ—¶æ‰è®¡ç®—è´¨é‡å¥–åŠ±
                if png_path and os.path.exists(png_path):
                    # è®¡ç®—è´¨é‡å¥–åŠ±
                    quality_reward = self.reward_model._compute_quality_reward(current, html_path, png_path)
                    print(f"âœ“ è´¨é‡å¥–åŠ±è®¡ç®—å®Œæˆ: {quality_reward:.2f}")
                    
                    # ä½¿ç”¨è´¨é‡å¥–åŠ±ä½œä¸ºæ€»å¥–åŠ±
                    reward = quality_reward
                else:
                    print(f"âš ï¸ æœªæ‰¾åˆ°PNGå›¾è¡¨ï¼Œæ— æ³•è®¡ç®—è´¨é‡å¥–åŠ±ï¼Œä½¿ç”¨é»˜è®¤å¥–åŠ±å€¼: {reward:.2f}")
                    
                print(f"âœ“ æœ€ç»ˆå¥–åŠ±: {reward:.2f}")
                
            except Exception as e:
                print(f"âŒ å¥–åŠ±è®¡ç®—å‡ºé”™: {str(e)}")
                print(f"âš ï¸ ä½¿ç”¨é»˜è®¤å¥–åŠ±å€¼: {reward:.2f}")
        else:
            # æœªè¾¾åˆ°ç»ˆæ­¢çŠ¶æ€ï¼Œè¿”å›é»˜è®¤å¥–åŠ±
            print(f"âš ï¸ æœªè¾¾åˆ°ç»ˆæ­¢çŠ¶æ€ï¼Œä½¿ç”¨é»˜è®¤å¥–åŠ±å€¼: {reward:.2f}")
        
        return current, reward

    def backpropagate(self, node: MCTSNode, reward: float):
        """
        å›æº¯é˜¶æ®µï¼šæ›´æ–°è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„ç»Ÿè®¡ä¿¡æ¯
        """
        while node is not None:
            node.N += 1
            node.Q += reward  # ä½¿ç”¨åŒæ ·çš„å¥–åŠ±å€¼æ›´æ–°æ•´æ¡è·¯å¾„
            node = node.parent_node

    def update_selected_path_iteration(self, node: MCTSNode) -> None:
        """
        æ›´æ–°é€‰ä¸­è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„è¿­ä»£å·ï¼Œå¹¶å¤åˆ¶ä¹‹å‰è¿­ä»£çš„å›¾è¡¨åˆ°å½“å‰è¿­ä»£
        
        å‚æ•°:
            node: å½“å‰é€‰ä¸­çš„èŠ‚ç‚¹
        """
        import os
        import re
        import shutil
        
        current_iteration = self.root.report.current_iteration
        
        # å‘ä¸Šæ›´æ–°è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹
        while node is not None:
            old_iteration = node.report.current_iteration
            
            # æ›´æ–°è¿­ä»£å·
            node.report.current_iteration = current_iteration
            
            # åªæœ‰å½“æ—§è¿­ä»£å·ä¸å½“å‰è¿­ä»£å·ä¸åŒæ—¶ï¼Œæ‰éœ€è¦å¤åˆ¶å›¾è¡¨å’Œæ›´æ–°è·¯å¾„
            if old_iteration != current_iteration:
                # ç¡®ä¿å½“å‰è¿­ä»£çš„å›¾è¡¨ç›®å½•å­˜åœ¨
                current_charts_dir = os.path.join(self.output_dir, "iterations", f"iteration_{current_iteration}", "charts")
                os.makedirs(current_charts_dir, exist_ok=True)
                
                # éå†æ‰€æœ‰ç« èŠ‚å’Œå›¾è¡¨
                for chapter in node.report.chapters:
                    for chart in getattr(chapter, 'charts', []):
                        if hasattr(chart, 'url') and chart.url:
                            # æ£€æŸ¥å›¾è¡¨URLæ˜¯å¦åŒ…å«æ—§è¿­ä»£çš„è·¯å¾„
                            old_iteration_pattern = rf"iteration_{old_iteration}"
                            if old_iteration_pattern in chart.url:
                                try:
                                    # è·å–å›¾è¡¨æ–‡ä»¶å
                                    chart_filename = os.path.basename(chart.url)
                                    
                                    # æ„å»ºæ—§è·¯å¾„å’Œæ–°è·¯å¾„
                                    old_chart_path = chart.url
                                    new_chart_path = os.path.join(current_charts_dir, chart_filename)
                                    
                                    # æ„å»ºæ–°çš„URL
                                    new_chart_url = os.path.join(
                                        self.output_dir, "iterations", 
                                        f"iteration_{current_iteration}", "charts", chart_filename
                                    )
                                    
                                    # å¤åˆ¶å›¾è¡¨æ–‡ä»¶ï¼Œå¦‚æœå­˜åœ¨çš„è¯
                                    if os.path.exists(old_chart_path):
                                        shutil.copy2(old_chart_path, new_chart_path)
                                        print(f"âœ… å·²å¤åˆ¶å›¾è¡¨ä» {old_chart_path} åˆ° {new_chart_path}")
                                    else:
                                        print(f"âš ï¸ æœªæ‰¾åˆ°æºå›¾è¡¨æ–‡ä»¶: {old_chart_path}")
                                    
                                    # æ›´æ–°å›¾è¡¨URL
                                    chart.url = new_chart_url
                                    print(f"âœ… å·²æ›´æ–°å›¾è¡¨URLä¸º: {new_chart_url}")
                                    
                                except Exception as e:
                                    print(f"âŒ å¤åˆ¶å›¾è¡¨æ—¶å‡ºé”™: {str(e)}")
            
            # ç»§ç»­å‘ä¸Šéå†
            node = node.parent_node

    def solve(self) -> MCTSNode:
        """æ‰§è¡Œ MCTS æœç´¢"""
        # è®¾ç½®æ—¥å¿—æ–‡ä»¶è·¯å¾„
        log_file = os.path.join("storyteller", "output", "log.txt")
        os.makedirs(os.path.dirname(log_file), exist_ok=True)
        
        # ä¿å­˜åŸå§‹çš„æ ‡å‡†è¾“å‡º
        original_stdout = sys.stdout
        
        # æ‰“å¼€æ—¥å¿—æ–‡ä»¶
        log_f = open(log_file, 'w', encoding='utf-8')
        
        class TeeOutput:
            def __init__(self, file):
                self.file = file
                self.stdout = original_stdout
            
            def write(self, message):
                self.stdout.write(message)
                self.file.write(message)
                self.file.flush()
            
            def flush(self):
                self.stdout.flush()
                self.file.flush()
        
        # è®¾ç½®è¾“å‡ºé‡å®šå‘
        sys.stdout = TeeOutput(log_f)
        
        try:
            print("\nğŸ” MCTS æœç´¢å¼€å§‹")
            print("=" * 50)
            print(f"å¼€å§‹æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            
            # åˆ›å»ºå†å²è®°å½•ç›®å½•
            history_dir = os.path.join(self.output_dir, "iterations")
            os.makedirs(history_dir, exist_ok=True)
            
            start_time = datetime.now()
            best_node = None
            best_score = float('-inf')
            
            for iteration in range(self.max_iterations):
                # è®¾ç½®å½“å‰è¿­ä»£å·
                self.root.report.current_iteration = iteration + 1
                print(f"Debug: è®¾ç½®æ ¹èŠ‚ç‚¹è¿­ä»£å·ä¸º {self.root.report.current_iteration}")
                
                # åˆ›å»ºå½“å‰è¿­ä»£çš„ç›®å½•
                iteration_dir = os.path.join(history_dir, f"iteration_{iteration + 1}")
                os.makedirs(iteration_dir, exist_ok=True)
                os.makedirs(os.path.join(iteration_dir, "charts"), exist_ok=True)
                
                print(f"\nğŸŒ€ **MCTS è¿­ä»£ {iteration + 1}/{self.max_iterations}**")
                
                # é€‰æ‹©
                leaf = self.select(self.root)
                print(f"ğŸ‘‰ é€‰æ‹© `Node` (æ·±åº¦ {leaf.depth}) | çŠ¶æ€: {leaf.node_type}")
                
                # æ›´æ–°é€‰ä¸­è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„è¿­ä»£å·
                self.update_selected_path_iteration(leaf)
                print(f"Debug: å·²æ›´æ–°é€‰ä¸­èŠ‚ç‚¹è¿­ä»£å·ä¸º {leaf.report.current_iteration}")
                
                # æ‰©å±•
                self.expand(leaf)
                
                # å¦‚æœæ‰©å±•æˆåŠŸå¹¶ç”Ÿæˆäº†å­èŠ‚ç‚¹ï¼Œä»å­èŠ‚ç‚¹ä¸­é€‰æ‹©ä¸€ä¸ªè¿›è¡Œæ¨¡æ‹Ÿ
                if leaf.children:
                    # éšæœºé€‰æ‹©ä¸€ä¸ªå­èŠ‚ç‚¹è¿›è¡Œæ¨¡æ‹Ÿ
                    child_for_simulation = random.choice(leaf.children)
                    # æ¨¡æ‹Ÿ
                    final_node, simulated_reward = self.simulate(child_for_simulation)
                else:
                    # å¦‚æœæ²¡æœ‰å­èŠ‚ç‚¹ï¼Œå¯ä»¥ç›´æ¥å¯¹å½“å‰èŠ‚ç‚¹è¿›è¡Œæ¨¡æ‹Ÿ
                    final_node, simulated_reward = self.simulate(leaf)
                
                # ä¿å­˜è¿™æ¬¡è¿­ä»£çš„ç»“æœ - ä½¿ç”¨æ¨¡æ‹Ÿè¿”å›çš„æœ€ç»ˆèŠ‚ç‚¹
                iteration_dir = os.path.join(history_dir, f"iteration_{iteration + 1}")
                os.makedirs(iteration_dir, exist_ok=True)
                
                # ä¿å­˜HTMLæŠ¥å‘Š - åŒæ—¶è·å–åŸå§‹å†…å®¹
                html_path, original_contents = self._save_html_report(final_node, 
                    output_path=os.path.join(iteration_dir, "report.html"))
                
                # ä¿å­˜æŠ¥å‘Šæˆªå›¾ - ä½¿ç”¨åŸå§‹å†…å®¹(ç»å¯¹è·¯å¾„)
                # éšæœºé€‰æ‹©ä¸€ä¸ªHTMLæ–‡ä»¶è¿›è¡ŒPNGè½¬æ¢
                html_files = [f for f in os.listdir(iteration_dir) if f.endswith('.html')]
                if html_files:
                    selected_html = html_files[0]  # ä½¿ç”¨ç¬¬ä¸€ä¸ªHTMLæ–‡ä»¶
                    selected_html_path = os.path.join(iteration_dir, selected_html)
                    
                    # ä¸´æ—¶ä½¿ç”¨åŸå§‹å†…å®¹(ç»å¯¹è·¯å¾„)
                    if selected_html in original_contents:
                        with open(selected_html_path, 'w', encoding='utf-8') as f:
                            f.write(original_contents[selected_html])
                    
                    # è½¬æ¢ä¸ºPNG
                    image_path = os.path.splitext(selected_html_path)[0] + ".png"
                    convert_html_file_to_image(selected_html_path, image_path)
                    
                    # æ¢å¤ä¸ºç›¸å¯¹è·¯å¾„ç‰ˆæœ¬
                    html_content = original_contents[selected_html]
                    user_home = os.path.expanduser("~")
                    project_base = os.path.join(user_home, "mcts")
                    if os.path.exists(project_base):
                        html_content = html_content.replace(project_base, "")
                    else:
                        import re
                        pattern = r'(src=")(\/.*?\/mcts)(\/storyteller\/.*?\.png")'
                        html_content = re.sub(pattern, r'\1\3', html_content)
                    
                    with open(selected_html_path, 'w', encoding='utf-8') as f:
                        f.write(html_content)
                else:
                    # å¦‚æœæ²¡æ‰¾åˆ°HTMLæ–‡ä»¶ï¼Œä½¿ç”¨é»˜è®¤è·¯å¾„
                    image_path = os.path.join(iteration_dir, "report.png")
                
                # ä¿å­˜è¯„åˆ†ä¿¡æ¯
                score_info = {
                    "iteration": iteration + 1,
                    "score": float(simulated_reward),
                    "score_breakdown": {
                        "quality_reward": simulated_reward
                    },
                    "is_best": simulated_reward > best_score,
                    "node_type": final_node.node_type.name,
                    "depth": final_node.depth,
                    "chapter_count": len(final_node.report.chapters),
                    "chart_count": sum(len(chapter.charts) for chapter in final_node.report.chapters),
                    "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "elapsed_time": str(datetime.now() - start_time)
                }
                
                with open(os.path.join(iteration_dir, "score.json"), 'w', encoding='utf-8') as f:
                    json.dump(score_info, f, indent=2, ensure_ascii=False)
                
                print(f"âœ… è¿­ä»£ {iteration + 1} æŠ¥å‘Šå·²ä¿å­˜åˆ°: {iteration_dir}")
                print(f"   å¾—åˆ†: {simulated_reward:.2f}")
                
                # å¦‚æœæ‰¾åˆ°æ›´å¥½çš„å®Œæ•´æŠ¥å‘Š
                if simulated_reward > best_score:
                    best_score = simulated_reward
                    best_node = copy.deepcopy(final_node)
                    print(f"ğŸ“ˆ æ‰¾åˆ°æ›´å¥½çš„å®Œæ•´æŠ¥å‘Šï¼å¾—åˆ†: {best_score:.2f}")
                
                # å›æº¯
                self.backpropagate(leaf, simulated_reward)
                print(f"   ğŸ“Š `Q` å€¼æ›´æ–°: {leaf.Q}, è®¿é—®æ¬¡æ•°: {leaf.N}")
                print("-" * 50)
            
            # ä¿å­˜æœç´¢å†å²ç»Ÿè®¡ä¿¡æ¯
            history_summary = {
                "total_iterations": self.max_iterations,
                "completed_iterations": iteration + 1,
                "best_score": float(best_score),
                "best_iteration": max(range(1, iteration + 2), 
                    key=lambda i: os.path.exists(os.path.join(history_dir, f"iteration_{i}", "score.json")) and 
                        json.load(open(os.path.join(history_dir, f"iteration_{i}", "score.json")))["score"]),
                "final_depth": best_node.depth if best_node else 0,
                "start_time": start_time.strftime("%Y-%m-%d %H:%M:%S"),
                "completion_time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "total_duration": str(datetime.now() - start_time)
            }
            
            with open(os.path.join(history_dir, "search_summary.json"), 'w', encoding='utf-8') as f:
                json.dump(history_summary, f, indent=2, ensure_ascii=False)

            print("\nâœ… MCTS æœç´¢å®Œæˆï¼")
            print("=" * 50)
            
            if best_node.node_type.name == "FINALIZED":
                print(f"ğŸ¯ è¿”å›æœ€ä½³å®Œæ•´æŠ¥å‘Š | å¾—åˆ†: {best_score:.2f}")
                return best_node
            else:
                print("âš ï¸ æœªæ‰¾åˆ°å®Œæ•´æŠ¥å‘Šï¼Œè¿”å›æ ¹èŠ‚ç‚¹")
                return self.root
            
        finally:
            # æ¢å¤åŸå§‹è¾“å‡º
            sys.stdout = original_stdout
            # å…³é—­æ—¥å¿—æ–‡ä»¶
            log_f.close()

    def _save_html_report(self, node: MCTSNode, output_path: str = None) -> str:
        """
        ç”Ÿæˆå¹¶ä¿å­˜HTMLæŠ¥å‘Š
        
        å‚æ•°:
            node: å½“å‰èŠ‚ç‚¹
            output_path: æŒ‡å®šè¾“å‡ºè·¯å¾„ï¼ˆå¯é€‰ï¼‰
            
        è¿”å›:
            str: HTMLæ–‡ä»¶è·¯å¾„
        """
        try:
            # ç¡®å®šè¾“å‡ºç›®å½•
            if output_path is None:
                # ä½¿ç”¨iterationsç›®å½•è€Œä¸æ˜¯temp
                default_dir = os.path.join(self.output_dir, "iterations", "default")
                os.makedirs(default_dir, exist_ok=True)
                output_path = os.path.join(default_dir, "report.html")
            
            output_dir = os.path.dirname(output_path)
            os.makedirs(output_dir, exist_ok=True)
            
            # 1. ç”ŸæˆMarkdownæŠ¥å‘Š
            markdown_content = self._generate_markdown_report(node)
            
            # 2. ä¿å­˜Markdownæ–‡ä»¶
            md_path = os.path.join(output_dir, "report.md")
            with open(md_path, 'w', encoding='utf-8') as f:
                f.write(markdown_content)
            
            # 3. è°ƒç”¨process_all_reports.pyç”Ÿæˆæ‰€æœ‰æ¨¡æ¿é£æ ¼çš„æŠ¥å‘Š
            script_dir = os.path.dirname(os.path.abspath(__file__))
            process_script = os.path.join(script_dir, "utils", "process_all_reports.py")
            
            print(f"æ­£åœ¨ä¸º {output_dir} ç”Ÿæˆæ‰€æœ‰é£æ ¼çš„æŠ¥å‘Š...")
            process_result = subprocess.run([
                'python', 
                process_script,
                '--all',
                '--dir', output_dir
            ], check=True, capture_output=True, text=True)
            
            # å°†å­è¿›ç¨‹è¾“å‡ºå†™å…¥æ—¥å¿—
            if process_result.stdout:
                print("--- HTMLç”Ÿæˆè¿‡ç¨‹è¾“å‡º ---")
                print(process_result.stdout)
            if process_result.stderr:
                print("--- HTMLç”Ÿæˆè¿‡ç¨‹é”™è¯¯ ---")
                print(process_result.stderr)
            
            # å¦‚æœæŒ‡å®šçš„è¾“å‡ºè·¯å¾„ä¸å­˜åœ¨ï¼Œä½†ç›®å½•ä¸­å­˜åœ¨å…¶ä»–HTMLæ–‡ä»¶ï¼Œåˆ™ä½¿ç”¨å…¶ä¸­ä¸€ä¸ª
            if not os.path.exists(output_path):
                html_files = [f for f in os.listdir(output_dir) if f.endswith('.html')]
                if html_files:
                    output_path = os.path.join(output_dir, html_files[0])
                    print(f"ä½¿ç”¨ç”Ÿæˆçš„HTMLæ–‡ä»¶: {output_path}")
            
            # 4. å¤„ç†æ‰€æœ‰HTMLæ–‡ä»¶ï¼Œå°†ç»å¯¹è·¯å¾„æ›¿æ¢ä¸ºç›¸å¯¹è·¯å¾„
            # ä½†åœ¨å¤„ç†å‰å…ˆä¿å­˜åŸå§‹çš„HTMLå†…å®¹(ç”¨ç»å¯¹è·¯å¾„)ä»¥ä¾¿ç”ŸæˆPNG
            html_files = [f for f in os.listdir(output_dir) if f.endswith('.html')]
            original_contents = {}
            
            # å…ˆä¿å­˜æ‰€æœ‰HTMLåŸå§‹å†…å®¹ï¼ˆç”¨äºç”ŸæˆPNGï¼‰
            for html_file in html_files:
                html_file_path = os.path.join(output_dir, html_file)
                try:
                    with open(html_file_path, 'r', encoding='utf-8') as f:
                        original_contents[html_file] = f.read()
                except Exception as e:
                    print(f"âŒ è¯»å–HTMLæ–‡ä»¶ {html_file} æ—¶å‡ºé”™: {str(e)}")
            
            # å¤„ç†HTMLæ–‡ä»¶ï¼Œä¿®æ”¹ä¸ºç›¸å¯¹è·¯å¾„ï¼ˆç”¨äºç”¨æˆ·æŸ¥çœ‹ï¼‰
            for html_file in html_files:
                html_file_path = os.path.join(output_dir, html_file)
                try:
                    html_content = original_contents[html_file]
                    
                    # è·å–å½“å‰ç”¨æˆ·ç›®å½•è·¯å¾„
                    user_home = os.path.expanduser("~")
                    project_base = os.path.join(user_home, "mcts")
                    
                    # æ›¿æ¢ç»å¯¹è·¯å¾„ä¸ºç›¸å¯¹è·¯å¾„
                    if os.path.exists(project_base):
                        # å°†ç»å¯¹è·¯å¾„"/Users/username/mcts/storyteller/..."æ›¿æ¢ä¸º"/storyteller/..."
                        html_content = html_content.replace(project_base, "")
                    else:
                        # å¦‚æœæ‰¾ä¸åˆ°é¡¹ç›®æ ¹ç›®å½•ï¼Œå°è¯•é€šç”¨æ›¿æ¢
                        import re
                        # åŒ¹é…ç±»ä¼¼"/Users/xxx/mcts/storyteller/"çš„è·¯å¾„
                        pattern = r'(src=")(\/.*?\/mcts)(\/storyteller\/.*?\.png")'
                        html_content = re.sub(pattern, r'\1\3', html_content)
                    
                    # ä¿å­˜ä¿®æ”¹åçš„HTMLå†…å®¹
                    with open(html_file_path, 'w', encoding='utf-8') as f:
                        f.write(html_content)
                    
                    print(f"âœ… å·²ä¿®å¤HTMLæ–‡ä»¶ä¸­çš„å›¾ç‰‡è·¯å¾„: {html_file}")
                
                except Exception as e:
                    print(f"âŒ å¤„ç†HTMLæ–‡ä»¶ {html_file} æ—¶å‡ºé”™: {str(e)}")
            
            return output_path, original_contents
        
        except Exception as e:
            print(f"âŒ ä¿å­˜HTMLæŠ¥å‘Šæ—¶å‡ºé”™: {str(e)}")
            raise e

    def _generate_markdown_report(self, node: MCTSNode) -> str:
        """ç”Ÿæˆ Markdown æŠ¥å‘Š"""
        markdown = []
        
        # 1. æŠ¥å‘Šæ ‡é¢˜
        markdown.append("# æ•°æ®åˆ†ææŠ¥å‘Š\n")
        
        # 2. æŠ¥å‘Šæ‘˜è¦
        if hasattr(node.report, 'key_abstract') and node.report.key_abstract:
            markdown.append("## æ‘˜è¦\n")
            markdown.append(node.report.key_abstract + "\n")
        
        # 3. ç« èŠ‚å†…å®¹
        for chapter in node.report.chapters:
            # ç§»é™¤æ ‡é¢˜ä¸­çš„å­—å…¸æ ¼å¼
            chapter_title = chapter.title
            if isinstance(chapter_title, str) and chapter_title.startswith("{'title': '") and chapter_title.endswith("'}"):
                chapter_title = chapter_title[len("{'title': '"):-2]
            
            markdown.append(f"\n## {chapter_title}\n")
            
            # æ·»åŠ å›¾è¡¨å’Œè¯´æ˜
            for chart in getattr(chapter, 'charts', []):
                # å…ˆæ·»åŠ å›¾è¡¨è¯´æ˜
                if hasattr(chart, 'caption') and chart.caption:
                    markdown.append(f"\n> {chart.caption}\n")
                
                # å¤„ç†å›¾è¡¨URL
                if hasattr(chart, 'url') and chart.url:
                    try:
                        # è·å–å›¾ç‰‡æ–‡ä»¶å
                        img_filename = os.path.basename(chart.url)
                        print(f"å¤„ç†å›¾ç‰‡: {img_filename}")
                        print(f"åŸå§‹URL: {chart.url}")
                        
                        # ä½¿ç”¨ç›¸å¯¹è·¯å¾„ï¼Œç¡®ä¿è·¯å¾„æ­£ç¡®
                        markdown.append(f"\n![{chapter_title}](charts/{img_filename})\n")
                    except Exception as e:
                        print(f"âŒ å¤„ç†å›¾ç‰‡è·¯å¾„æ—¶å‡ºé”™: {str(e)}")
                        continue
            
            # æ·»åŠ ç« èŠ‚æ€»ç»“
            if hasattr(chapter, 'summary') and chapter.summary:
                markdown.append("\n### Chapter Summary\n")
                markdown.append(chapter.summary + "\n")
        
        # 4. æŠ¥å‘Šæ€»ç»“
        if hasattr(node.report, 'brief_conclusion') and node.report.brief_conclusion:
            markdown.append("\n## æ€»ç»“ä¸å»ºè®®\n")
            markdown.append(node.report.brief_conclusion + "\n")
        
        return "\n".join(markdown)

    def _generate_html_report(self, markdown_content: str, output_dir: str) -> str:
        """
        æ­¤æ–¹æ³•ä¸å†ä½¿ç”¨ï¼Œä¿ç•™ä½œä¸ºå†å²è®°å½•
        """
        return ""
